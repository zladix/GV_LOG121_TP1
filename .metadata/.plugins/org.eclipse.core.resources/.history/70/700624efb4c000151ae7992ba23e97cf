/******************************************************
Cours:  LOG121
Projet: Squelette du laboratoire #1
Nom du fichier: CommBase.java
Date crÃ©Ã©: 2013-05-03
*******************************************************
Historique des modifications
*******************************************************
*@author Patrice Boucher
2013-05-03 Version initiale
*******************************************************/  

import java.beans.PropertyChangeListener;

import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import java.net.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;

/**
 * Base d'une communication via un fil d'exÃ©cution parallÃ¨le.
 */
public class CommBase {
	
	private final int DELAI = 1000;
	private SwingWorker threadComm =null;
	private PropertyChangeListener listener = null;
	private boolean isActif = false;
	private Socket socket = null;
	private BufferedReader in = null;
	private PrintWriter out = null;
	private String contenuChaine = null;
	/**
	 * Constructeur
	 */
	public CommBase(){
	}
	
	/**
	 * Définir le récepteur de l'information reçue dans la communication avec le serveur
	 * @param listener sera alertÃ© lors de l'appel de "firePropertyChanger" par le SwingWorker
	 */
	public void setPropertyChangeListener(PropertyChangeListener listener){
		this.listener = listener;
	}
	
	/**
	 * DÃ©marre la communication
	 */
	public void start(){
		creerCommunication();
	}
	
	/**
	 * ArrÃªte la communication
	 */
	public void stop(){
		fermerConnexionServeur();
		if(threadComm!=null)
			threadComm.cancel(true); 
		isActif = false;
	}
	
	/**
	 * CrÃ©er le nÃ©cessaire pour la communication avec le serveur
	 */
	protected void creerCommunication(){		
		// CrÃ©e un fil d'exÃ©cusion parallÃ¨le au fil courant,
		threadComm = new SwingWorker(){
			@Override
			protected Object doInBackground() throws Exception {
				System.out.println("Le fils d'execution parallele est lance");
				try {
					socket = new Socket(InetAddress.getLocalHost(),10000);
					in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
					out = new PrintWriter(socket.getOutputStream());
					isActif = socket.isConnected();
				}catch (Exception e) {
					isActif = false;
					System.out.println(e);
				}
				while(isActif){
					Thread.sleep(DELAI);
					communicationServeur();
					
 					//La mÃ©thode suivante alerte l'observateur 
					if(listener!=null)
					   firePropertyChange("ENVOIE-TEST", null, (Object) "."); 
				}
				return null;
			}
		};
		if(listener!=null)
		   threadComm.addPropertyChangeListener(listener); // La mÃ©thode "propertyChange" de ApplicationFormes sera donc appelÃ©e lorsque le SwinkWorker invoquera la mÃ©thode "firePropertyChanger" 		
		threadComm.execute(); // Lance le fil d'exÃ©cution parallÃ¨le.
		isActif = true;
	}
	
	/**
	 * @return si le fil d'exÃ©cution parallÃ¨le est actif
	 */
	public boolean isActif(){
		return isActif;
	}
	
	/**
	 * Envoi "GET" au serveur et récupère la réponse
	 */
	protected void communicationServeur()
	{
		CreateurForme creation = new CreateurForme();
		OrganiseForme tabForme = new OrganiseForme();
		
		//On peu communiquer avec le serveur
			try{
				if(socket.isConnected() == true && socket.isClosed() == false)
				{
					out.println("GET");
					out.flush();
					contenuChaine = in.readLine();
					if(contenuChaine.equals("commande> ") == false)
					{
						System.out.println(contenuChaine);
						//Envoi de la chaine contenant la forme
						
						Forme uneForme = creation.creerForme(contenuChaine);
						tabForme.AjoutForme(uneForme);
					}
				}
			}catch(Exception e)
			{
				JOptionPane.showMessageDialog(null,"La connexion au serveur n'a pas pu être effectuée. Assurez-vous que le serveur est bien ouvert.", "Erreur Connexion",
					    JOptionPane.ERROR_MESSAGE);
				stop();
			}
	}
	
	/**
	 * Ferme la connexion avec le serveur en lui envoyant la commande "END".
	 */
	protected void fermerConnexionServeur()
	{
		try{
			in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
			out = new PrintWriter(socket.getOutputStream());
			out.println("END");
			out.flush();
			socket.close();
			System.out.println("\nCommunication fermée");
		}catch(Exception e)
		{
			System.out.println(e);
		}
	}
}
